Nodes
  = Node*

Node
  = Include
  / Block
  / Var
  / Expression
  / Plain

// Includes

Include "include"
  = IncludeSelfClosing
  / IncludeWithDefs

IncludeSelfClosing
  = tag: IncludeTagStart '/>'
  {
    return {
      type: 'include',
      file: tag.file,
      nodes: []
    }
  }

IncludeWithDefs
  = tag: IncludeTagStart '>' ws* nodes:IncludeNodes '</include' ws* '>'
  {
    return {
      type: 'include',
      file: tag.file,
      nodes: nodes
    }
  }

IncludeTagStart
  = '<include' ws+ 'file' ws* '=' ws* file:AttrValue ws*
  {
    return {
      file: file
    }
  }

IncludeNodes
  = IncludeNode*

IncludeNode
  = node: Def ws* { return node }
  / node: Var ws* { return node }

// Defs

Def "definition"
  = '<' def: DefTag ':' name: VarName ws* '>'
    nodes: Nodes
    '</' _def: DefTag & { return def == _def }
    ':'
    _name: VarName & { return name == _name }
    ws* '>'
  {
    return {
      type: 'def',
      mode: def,
      name: name,
      nodes: nodes
    }
  }
  
DefTag
  = 'def'
  / 'append'
  / 'prepend'

// Blocks

Block "block"
  = BlockSelfClosing
  / BlockWithContent

BlockSelfClosing
  = '<block:' name: VarName ws* '/>'
  {
    return {
      type: 'block',
      name: name,
      nodes: []
    }
  }

BlockWithContent
  = '<block:' name: VarName ws* '>'
    nodes: Nodes
    '</block:' _name: VarName & { return name == _name }
    ws* '>'
  {
    return {
      type: 'block',
      name: name,
      nodes: nodes
    }
  }

// Var

Var
  = '<var:' name: VarName ws* '>'
    expr: $(ExpressionTokens)
    '</var:' _name: VarName & { return name == _name }
    ws* '>'
  {
    return {
      type: 'var',
      name: name,
      expr: expr
    }
  }

// Expression

Expression "expression"
  = EscapedExpression
  / UnescapedExpression
  / UnbufferedExpression

EscapedExpression
  = '#{' expr: $(ExpressionTokens) '}'
  {
    return {
      type: 'expr',
      escape: true,
      buffer: true,
      expr: expr
    }
  }

UnescapedExpression
  = '!{' expr: $(ExpressionTokens) '}'
  {
    return {
      type: 'expr',
      escape: false,
      buffer: true,
      expr: expr
    }
  }

UnbufferedExpression
  = '${' expr: $(ExpressionTokens) '}'
  {
    return {
      type: 'expr',
      escape: false,
      buffer: false,
      expr: expr
    }
  }

ExpressionTokens
  = ExpressionToken+

ExpressionToken
  = StringLiteral
  / ObjectLiteral
  / [^}{"'<]
  / '<' !'/var'

ObjectLiteral
  = '{' ExpressionTokens '}'

StringLiteral "string"
  = '"' DoubleStringCharacter* '"'
  / "'" SingleStringCharacter* "'"

DoubleStringCharacter
  = !'"' !'\\' SourceCharacter
  / EscapeSequence

SingleStringCharacter
  = !"'" !'\\' SourceCharacter
  / EscapeSequence

SourceCharacter
  = [^\n\r\u2028\u2029]

EscapeSequence
  = '\\' SourceCharacter

// Plain text

Plain "plain text"
  = $(PlainToken+)

PlainToken
  = [^<#!$]
  / '<' '/'?
    !'include'
    !'block'
    !'def'
    !'append'
    !'prepend'
    !'var'
  / [#!$] !'{'

// Commons

VarName "variable name"
  = $( [a-z] [a-zA-Z0-9_]* )

AttrValue "attribute value"
  = SingleQuoteString
  / DoubleQuoteString

SingleQuoteString "string"
  = "'" chars:$([^']*) "'"
  { return chars }

DoubleQuoteString "string"
  = '"' chars:$([^"]*) '"'
  { return chars }

ws "whitespace"
  = [ \t\n\r]
